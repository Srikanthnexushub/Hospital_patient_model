# Implementation Plan: Billing & Invoicing Module

**Branch**: `004-billing-module` | **Date**: 2026-02-20 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/004-billing-module/spec.md`

---

## Summary

Module 4 adds full billing lifecycle management to the hospital system. It generates invoices linked to completed appointments, records payments (updating balances atomically), supports admin-only cancel/write-off operations, and provides a financial summary report. The implementation follows the established codebase patterns from Modules 1–3: no JPA navigation, repository composition, `Propagation.MANDATORY` audit service, and `PESSIMISTIC_WRITE`-locked ID generation.

---

## Technical Context

**Language/Version**: Java 17, Spring Boot 3.2.x
**Primary Dependencies**: Spring Data JPA, Spring Security (RoleGuard/AuthContext from Module 2), Flyway, MapStruct, Lombok, Micrometer (MeterRegistry)
**Storage**: PostgreSQL 15 — new tables V12–V16 via Flyway; existing V1–V11 untouched
**Testing**: JUnit 5, Mockito, Testcontainers (singleton pattern), BaseIntegrationTest
**Target Platform**: Same Maven module as Modules 1–3 (`com.ainexus.hospital.patient` package root)
**Performance Goals**: Invoice list + search < 1s for 10k records; financial report < 2s for any 30-day range
**Constraints**: No JPA navigation (@OneToMany/@ManyToOne); BigDecimal for all monetary arithmetic; NURSE denied on all billing endpoints
**Scale/Scope**: Up to 99,999 invoices/year (5-digit seq); paginated list API (max 100/page)

---

## Constitution Check

| Gate | Status | Notes |
|------|--------|-------|
| Spec-Driven | ✅ PASS | spec.md approved, all 5 US defined with acceptance criteria |
| HIPAA-First | ✅ PASS | Invoice amounts are financial PHI; audit log on every mutation |
| Test-First | ✅ PASS | tasks.md will enforce unit + integration tests before implementation |
| Layered Architecture | ✅ PASS | Controller → Service → Repository; DTOs at boundary |
| RBAC | ✅ PASS | NURSE denied; DOCTOR scoped to own patients; ADMIN-only for cancel/write-off/report |
| Tech Stack | ✅ PASS | Spring Boot 3.2.x, Java 17, PostgreSQL 15, same Maven module |
| Complexity | ✅ PASS | No new services/frameworks; mirrors existing module patterns exactly |

---

## Project Structure

### Documentation (this feature)

```text
specs/004-billing-module/
├── spec.md              ✅ Complete
├── research.md          ✅ Complete
├── data-model.md        ✅ Complete
├── quickstart.md        ✅ Complete
├── contracts/
│   └── invoices.yaml    ✅ Complete
├── checklists/
│   └── requirements.md  ✅ Complete
└── tasks.md             ← Generated by /speckit.tasks
```

### Source Code (backend)

```text
backend/src/main/java/com/ainexus/hospital/patient/

entity/
├── Invoice.java                     # Core invoice entity (@Version for optimistic lock)
├── InvoiceLineItem.java             # Immutable line item
├── InvoicePayment.java              # Immutable payment record
├── InvoiceAuditLog.java             # Append-only audit log (no @Version)
├── InvoiceIdSequence.java           # Per-year counter (mirrors PatientIdSequence)
└── enums/
    ├── InvoiceStatus.java           # DRAFT, ISSUED, PARTIALLY_PAID, PAID, CANCELLED, WRITTEN_OFF
    └── PaymentMethod.java           # CASH, CARD, INSURANCE, BANK_TRANSFER, CHEQUE

repository/
├── InvoiceRepository.java           # findByInvoiceId, findByPatientId, search with Specification
├── InvoiceLineItemRepository.java   # findByInvoiceId
├── InvoicePaymentRepository.java    # findByInvoiceId, sumByInvoiceIdGroupByMethod
├── InvoiceAuditLogRepository.java   # findByInvoiceId
└── InvoiceIdSequenceRepository.java # findByYearForUpdate (PESSIMISTIC_WRITE)

service/
├── InvoiceService.java              # Orchestrates all 5 use cases
├── InvoiceIdGeneratorService.java   # INV+YYYY+5-digit seq (mirrors AppointmentIdGeneratorService)
└── InvoiceAuditService.java         # Propagation.MANDATORY audit writes

dto/
├── request/
│   ├── CreateInvoiceRequest.java
│   ├── LineItemRequest.java
│   ├── RecordPaymentRequest.java
│   └── InvoiceStatusUpdateRequest.java
└── response/
    ├── InvoiceDetailResponse.java
    ├── InvoiceSummaryResponse.java
    ├── LineItemResponse.java
    ├── PaymentResponse.java
    ├── PagedInvoiceSummaryResponse.java
    └── FinancialReportResponse.java

mapper/
└── InvoiceMapper.java               # MapStruct: Invoice ↔ InvoiceDetailResponse/InvoiceSummaryResponse

controller/
├── InvoiceController.java           # POST /invoices, GET /invoices, GET /invoices/{id}, PATCH status, POST payments
├── PatientInvoiceController.java    # GET /patients/{patientId}/invoices
└── FinancialReportController.java   # GET /reports/financial

exception/
└── (reuse GlobalExceptionHandler — add InvoiceNotFoundException, InvalidInvoiceTransitionException)

resources/db/migration/
├── V12__create_invoices.sql         # invoices + invoice_id_sequences tables
├── V13__create_invoice_line_items.sql
├── V14__create_invoice_payments.sql
├── V15__create_invoice_audit_log.sql
└── V16__create_billing_indexes.sql

# Test classes
src/test/java/com/ainexus/hospital/patient/
├── unit/
│   ├── service/
│   │   ├── InvoiceServiceTest.java
│   │   └── InvoiceIdGeneratorServiceTest.java
│   └── controller/
│       └── InvoiceControllerTest.java       (optional — covered by IT)
└── integration/
    ├── InvoiceLifecycleIT.java              # US1: create, duplicate, monetary math
    ├── InvoiceSearchIT.java                 # US2: list, filter, DOCTOR scope
    ├── InvoicePaymentIT.java                # US3: partial, full, overpayment
    ├── InvoiceStatusIT.java                 # US4: cancel, write-off, invalid transitions
    ├── FinancialReportIT.java               # US5: report aggregations, empty range
    └── InvoiceRbacIT.java                   # Full role matrix across all 7 endpoints
```

### Frontend (future)

The billing UI is not in scope for this module's tasks. A future `004b-billing-ui` branch will add:
- Invoice list page with filters
- Invoice creation form
- Payment recording modal
- Financial report dashboard

---

## Key Implementation Decisions

### 1. ID Generation
`InvoiceIdGeneratorService` mirrors `AppointmentIdGeneratorService` exactly:
```java
@Transactional
public String generateInvoiceId() {
    int year = LocalDate.now().getYear();
    InvoiceIdSequence seq = repository.findByYearForUpdate(year)
        .orElseGet(() -> repository.save(new InvoiceIdSequence(year, 0)));
    seq.setLastSequence(seq.getLastSequence() + 1);
    return String.format("INV%d%05d", year, seq.getLastSequence());
}
```

### 2. Monetary Arithmetic
All amounts computed with `BigDecimal.setScale(2, RoundingMode.HALF_UP)`:
```java
BigDecimal totalAmount = lineItems.stream()
    .map(li -> li.getUnitPrice().multiply(BigDecimal.valueOf(li.getQuantity())))
    .reduce(BigDecimal.ZERO, BigDecimal::add)
    .setScale(2, RoundingMode.HALF_UP);

BigDecimal discountAmount = totalAmount
    .multiply(request.getDiscountPercent())
    .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);

BigDecimal netAmount = totalAmount.subtract(discountAmount);
BigDecimal taxAmount = netAmount
    .multiply(taxRate)
    .divide(BigDecimal.valueOf(100), 2, RoundingMode.HALF_UP);
BigDecimal amountDue = netAmount.add(taxAmount);
```

### 3. Payment Status Transition Logic
```java
invoice.setAmountPaid(invoice.getAmountPaid().add(payment.getAmount()));
invoice.setAmountDue(invoice.getAmountDue().subtract(payment.getAmount()));
InvoiceStatus newStatus = invoice.getAmountDue().compareTo(BigDecimal.ZERO) > 0
    ? InvoiceStatus.PARTIALLY_PAID
    : InvoiceStatus.PAID;
invoice.setStatus(newStatus);
```

### 4. DOCTOR Scoping (US2)
DOCTOR role filter applied in `InvoiceService.listInvoices()`:
```java
if (ctx.getRole().equals("DOCTOR")) {
    spec = spec.and(InvoiceSpecification.doctorId(ctx.getUsername()));
}
```
The `doctorId` column on `invoices` is denormalized from the appointment at creation time, enabling O(1) scoping without a join.

### 5. Financial Report — Native Query
The report uses a single native aggregation query rather than loading all invoices in Java:
```java
@Query(value = """
    SELECT
        COALESCE(SUM(i.total_amount), 0) as total_invoiced,
        COALESCE(SUM(CASE WHEN i.status IN ('ISSUED','PARTIALLY_PAID') THEN i.amount_due ELSE 0 END), 0) as total_outstanding,
        ...
    FROM invoices i
    WHERE i.created_at::date BETWEEN :dateFrom AND :dateTo
    """, nativeQuery = true)
FinancialReportProjection getFinancialSummary(LocalDate dateFrom, LocalDate dateTo);
```

### 6. Audit Service
```java
@Service
public class InvoiceAuditService {
    @Transactional(propagation = Propagation.MANDATORY)
    public void log(String invoiceId, String action, InvoiceStatus from, InvoiceStatus to,
                    String performedBy, String details) {
        InvoiceAuditLog entry = InvoiceAuditLog.builder()
            .invoiceId(invoiceId)
            .action(action)
            .fromStatus(from != null ? from.name() : null)
            .toStatus(to.name())
            .performedBy(performedBy)
            .performedAt(OffsetDateTime.now())
            .details(details)
            .build();
        auditLogRepository.save(entry);
    }
}
```

---

## Jackson Configuration (apply to application.yml)

```yaml
spring:
  jackson:
    serialization:
      write-big-decimal-as-plain: true

billing:
  tax-rate: 0.00
```

---

## Complexity Tracking

No constitution violations — all patterns are direct mirrors of existing modules.

---

## Dependency Graph

```
Flyway V12–V16 (entities, tables)
       ↓
InvoiceIdGeneratorService + InvoiceAuditService   [parallel with entity layer]
       ↓
InvoiceRepository + child repositories             [parallel]
       ↓
InvoiceService (orchestrates all use cases)
       ↓
InvoiceController + PatientInvoiceController + FinancialReportController   [parallel]
       ↓
Integration Tests (per user story)
```

US1 (Create) must land before US3 (Payment) and US4 (Status). US2 (Search) is independent. US5 (Report) depends on US1+US3 for meaningful test data.
